(in-package #:cl-freelock-benchmarks)

(defun run-single-threaded-baseline (items)
  "Runs a single-threaded benchmark using a simple list for a theoretical max."
  (let ((q nil))
    (format t "~&~%--- Baseline: Single-threaded list ---~%")
    (format t "    Total items: ~:D~%" items)
    (let ((start-time (get-internal-real-time)))
      (dotimes (i items)
        (push i q))
      (dotimes (i items)
        (pop q))
      (let* ((end-time (get-internal-real-time))
             (duration-seconds (/ (- end-time start-time) internal-time-units-per-second))
             ;; We do 2 operations per item (push and pop)
             (ops-per-second (if (> duration-seconds 0)
                                 (/ (* items 2) duration-seconds)
                                 0)))
        (format t "    Duration: ~,3F seconds~%" duration-seconds)
        (format t "    Throughput: ~,2F operations/sec~%" ops-per-second)))))

(defclass lock-based-queue ()
  ((lock :initform (bt:make-lock))
   (queue :initform nil)))

(defun lbq-push (lbq obj)
  (bt:with-lock-held ((slot-value lbq 'lock))
    (push obj (slot-value lbq 'queue))))

(defun lbq-pop (lbq)
  (bt:with-lock-held ((slot-value lbq 'lock))
    (pop (slot-value lbq 'queue))))

(defun run-lock-based-benchmark (num-producers num-consumers total-items)
  "Runs a benchmark for a simple list protected by a bordeaux-threads lock."
  (let* ((q (make-instance 'lock-based-queue))
         (items-per-producer (floor total-items num-producers))
         (popped-count (fl:make-atomic-ref 0))
         (producers nil)
         (consumers nil))
    (format t "~&~%--- Competitor: Lock-based list: ~D Producer(s), ~D Consumer(s) ---~%" num-producers num-consumers)
    (format t "    Total items: ~:D~%" total-items)
    (let ((start-time (get-internal-real-time)))
      (dotimes (i num-consumers)
        (push (make-thread (lambda () (loop (when (>= (atomic-ref-value popped-count) total-items) (return))
                                             (when (lbq-pop q) (atomic-incf popped-count)))))
              consumers))
      (dotimes (i num-producers)
        (push (make-thread (lambda () (dotimes (j items-per-producer) (lbq-push q j))))
              producers))
      (mapc #'join-thread producers)
      (loop until (>= (atomic-ref-value popped-count) total-items))
      (mapc #'join-thread consumers)
      (let* ((end-time (get-internal-real-time))
             (duration-seconds (/ (- end-time start-time) internal-time-units-per-second))
             (ops-per-second (if (> duration-seconds 0) (/ total-items duration-seconds) 0)))
        (format t "    Duration: ~,3F seconds~%" duration-seconds)
        (format t "    Throughput: ~,2F operations/sec~%" ops-per-second)))))

(handler-case
    (require :queues.simple-cqueue)
  (error (e)
    (format t "~&Warning: Could not load queues.simple-cqueue: ~A~%" e)
    (format t "~&Falling back to basic queues module~%")))

(defun run-oconnore-queue-benchmark (num-producers num-consumers total-items)
  "Runs a benchmark for oconnore/queues' concurrent queue."
  (handler-case
      (let* ((q (queues:make-queue :simple-cqueue))
             (items-per-producer (floor total-items num-producers))
             (popped-count (fl:make-atomic-ref 0))
             (producers nil)
             (consumers nil))
        (format t "~&~%--- Competitor: oconnore/queues (concurrent): ~D Producer(s), ~D Consumer(s) ---~%" num-producers num-consumers)
        (format t "    Total items: ~:D~%" total-items)
        (let ((start-time (get-internal-real-time)))
          (dotimes (i num-consumers)
            (push (make-thread (lambda () (loop (when (>= (atomic-ref-value popped-count) total-items) (return))
                                                 (multiple-value-bind (obj success) (queues:qpop q)
                                                   (when success (atomic-incf popped-count))))))
                  consumers))
          (dotimes (i num-producers)
            (push (make-thread (lambda () (dotimes (j items-per-producer) (queues:qpush q j))))
                  producers))
          (mapc #'join-thread producers)
          (loop until (>= (atomic-ref-value popped-count) total-items))
          (mapc #'join-thread consumers)
          (let* ((end-time (get-internal-real-time))
                 (duration-seconds (/ (- end-time start-time) internal-time-units-per-second))
                 (ops-per-second (if (> duration-seconds 0) (/ total-items duration-seconds) 0)))
            (format t "    Duration: ~,3F seconds~%" duration-seconds)
            (format t "    Throughput: ~,2F operations/sec~%" ops-per-second))))
    (error (e)
      (format t "~&~%--- Competitor: oconnore/queues (SKIPPED) ---~%")
      (format t "    Error: ~A~%" e))))

(defun run-all-competitor-benchmarks ()
  (format t "~&~%======================================================================~%")
  (format t "--- Competitor Benchmark Suite ---~%")
  (format t "======================================================================~%")
  (let ((num-items 1000000))
    (run-single-threaded-baseline (* 2 num-items))
    (run-lock-based-benchmark 1 1 num-items)
    (run-oconnore-queue-benchmark 1 1 num-items)
    (run-bounded-contention-benchmark 1 1 num-items)
    
    (run-lock-based-benchmark 4 4 num-items)
    (run-oconnore-queue-benchmark 4 4 num-items)
    (run-bounded-contention-benchmark 4 4 (floor num-items 4))))